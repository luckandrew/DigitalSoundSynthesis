
////////////////////////////////////////////////////////////////////////////////////////////////////
////Author: Andrew Luck
////DX Arts Digital Sound Synthesis 461A : Jo Anderson, Daniel Peterson
////Attribution: Code snippets from DXArts 461 Tutorial Set
////Last Modified: January 29th, 2018
////////////////////////////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 1A///////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


(

//////////////// DEFINE VARIABLES ////////////////

var note, score, synthDef;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, sampleRate, numOutputChannels;
//vars for harmonics
var additiveFunc, partialGains, partialRatios, partialArray, partialNils, numHarmonics;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = 44100;                   // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// create a score
score = CtkScore.new;

/////////////// DEFINE SYNTHS ///////////////

//synth definition
synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, gain, ris = 0.2, dec = 0.2, freq = 440.0;
    var env, envGen, sig, amp;
    amp = gain.dbamp;
    env = Env.linen(ris, 1.0 - (ris + dec), dec);
    envGen = EnvGen.kr(env, levelScale: amp, timeScale: dur);

    sig = SinOsc.ar(freq, 0, envGen);

    Out.ar([0, 1], sig)
});

///////////////// CREATE SCORE POPULATING FUNCTIONS //////////////////

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, gain = -12.0, ris = 0.1, dec = 0.1, freq = 880.0, partialGains, partialRatios; // pass in values

    var partialData;

    // group partial gains and ratios into a new array
    // NOTE: we could have required that this information is passed in to the function in this form..
    partialData = [partialGains, partialRatios];
    partialData = partialData.lace; // interlace the values
    partialData = partialData.reshape((partialData.size/2).asInteger, 2); // regroup values
    // partialData = partialData.flop; // or the .flop method does the above for us in one shot!

    // iterate through the partialData array to generate individual notes to add to the score
    partialData.do({arg thisPartialData, i;
        var thisPartialFreq;
        var thisPartialNote;

        var thisPartialGain;
        var thisPartialRatio;

        // retreive partial gain and ratio
        thisPartialGain = thisPartialData.at(0);
        thisPartialRatio = thisPartialData.at(1);

        thisPartialGain = gain + thisPartialGain; // scale partialGain by gain
        thisPartialFreq = freq * thisPartialRatio; // multiply freq by ratio, e.g., not necessarily harmonic!

        // create a note for each partial...
        thisPartialNote = synthDef.note(
            starttime: start, duration: dur
        )
        .dur_(dur)
        .gain_(thisPartialGain)
        .ris_(ris)
        .dec_(dec)
        .freq_(thisPartialFreq);

        // then and add note for each partial to the score
        score.add(thisPartialNote);
    })
};


///////////////// SET PARAMETER VALUES //////////////////

//var partialNils, partialArray, partialGains, numHarmonics;

numHarmonics = 10;

partialNils = Array.fill(numHarmonics/2, 0);

partialArray = (1/(Array.series(numHarmonics/2, 1,  2)));


//partialArray.postln;

partialGains = [partialArray, partialNils].lace.ampdb;
//partialGains.postln;

partialRatios = Array.series(partialGains.size, 1);  // harmonic series - generated by Array-series

///////////////// EVALUATE FUNCTIONS //////////////////

// evaluate the additive synthesis function
// args: start, dur, gain, ris, dec, freq, partialGains, partialRatios
// this function adds individual partials to the score to be played
additiveFunc.value(
 	    start: 0.1,
 	    dur: 8.0,
	    gain: -15.0,
	    ris: 0.1,
 	    dec: 0.1,
 	    freq: 110.0,
 	    partialGains: partialGains,
 	    partialRatios: partialRatios
 );

score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);
)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui;












////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 1B//////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


(

//////////////// DEFINE VARIABLES ////////////////

var note, score, synthDef;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, sampleRate, numOutputChannels;
//vars for harmonics
var additiveFunc, partialGains, partialRatios, partialArray, partialNils, numHarmonics;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = 44100;                   // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// create a score
score = CtkScore.new;

/////////////// DEFINE SYNTHS ///////////////

//synth definition
synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, gain, ris = 0.2, dec = 0.2, freq = 440.0;
    var env, envGen, sig, amp;
    amp = gain.dbamp;
    env = Env.linen(ris, 1.0 - (ris + dec), dec);
    envGen = EnvGen.kr(env, levelScale: amp, timeScale: dur);

    sig = SinOsc.ar(freq, 0, envGen);

    Out.ar([0, 1], sig)
});

///////////////// CREATE SCORE POPULATING FUNCTIONS //////////////////

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, gain = -12.0, ris = 0.1, dec = 0.1, freq = 880.0, partialGains, partialRatios; // pass in values

    var partialData;

    // group partial gains and ratios into a new array
    // NOTE: we could have required that this information is passed in to the function in this form..
    partialData = [partialGains, partialRatios];
    partialData = partialData.lace; // interlace the values
    partialData = partialData.reshape((partialData.size/2).asInteger, 2); // regroup values
    // partialData = partialData.flop; // or the .flop method does the above for us in one shot!

    // iterate through the partialData array to generate individual notes to add to the score
    partialData.do({arg thisPartialData, i;
        var thisPartialFreq;
        var thisPartialNote;

        var thisPartialGain;
        var thisPartialRatio;

        // retreive partial gain and ratio
        thisPartialGain = thisPartialData.at(0);
        thisPartialRatio = thisPartialData.at(1);

        thisPartialGain = gain + thisPartialGain; // scale partialGain by gain
        thisPartialFreq = freq * thisPartialRatio; // multiply freq by ratio, e.g., not necessarily harmonic!

        // create a note for each partial...
        thisPartialNote = synthDef.note(
            starttime: start, duration: dur
        )
        .dur_(dur)
        .gain_(thisPartialGain)
        .ris_(ris)
        .dec_(dec)
        .freq_(thisPartialFreq);

        // then and add note for each partial to the score
        score.add(thisPartialNote);
    })
};


///////////////// SET PARAMETER VALUES //////////////////

//////SQUARE///////

// //var partialNils, partialArray, partialGains, numHarmonics;
//
// numHarmonics = 10;
//
// partialNils = Array.fill(numHarmonics/2, 0);
//
// partialArray = (1/(Array.series(numHarmonics/2, 1,  2)));
// //partialArray.postln;
//
// partialGains = [partialArray, partialNils].lace.ampdb;
// //partialGains.postln;
//
// partialRatios = Array.series(partialGains.size, 1);  // harmonic series - generated by Array-series


//////TRIANGLE



// var partialNils, partialArray, partialGains, numHarmonics;

numHarmonics = 10;

partialNils = Array.fill(numHarmonics/2, 0);

partialArray = (1/(Array.series(numHarmonics/2, 3,  2).pow(2)));
//partialArray.postln;

partialGains = [partialArray, partialNils].lace.ampdb;
"Partial Gains is: ".post;
partialGains.postln;

partialRatios = Array.series(partialGains.size, 1);  // harmonic series - generated by Array-series

///////////////// EVALUATE FUNCTIONS //////////////////

// evaluate the additive synthesis function
// args: start, dur, gain, ris, dec, freq, partialGains, partialRatios
// this function adds individual partials to the score to be played
additiveFunc.value(
 	    start: 0.1,
 	    dur: 8.0,
	    gain: -15.0,
	    ris: 0.1,
 	    dec: 0.1,
 	    freq: 110.0,
 	    partialGains: partialGains,
 	    partialRatios: partialRatios
 );

score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);
)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui;











////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 2a///////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

/*Attribution:

[1] Partial Gains

Listed partial gains from Dodge and Jerse's Computer Music, Second Edition on page 105 fig 4.28

Risset's Bells

Partial No.2	Frequency Ratio3	Magnitude (in dB)4	Duration Scale	Partial Name
0	0.56	0.0	1.0	Hum
1	0.56 (+1)	-3.5	0.9	Hum (beating)
2	0.92	0.0	0.65	Prime
3	0.92 (+1.7)	5.1	0.55	Prime (beating)
4	1.19	8.5	0.325	Tierce
5	1.7	4.5	0.35
6	2.0	3.3	0.25	Nominal
7	2.74	2.5	0.2	(Undeciem)
8	3.0	2.5	0.15	Superquint
9	3.76	0.0	0.1
10	4.07	2.5	0.075	Octave Nominal*/


(

//////////////// DEFINE VARIABLES ////////////////

var score, synthDef;
var additiveFunc;
var partialGains, partialRatios, partialDurs, partialOffsets, partialData;

// helper functions
var sinCosPanLaw;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, numOutputChannels, sampleRate;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = 44100;                   // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// create a score
// the additiveFunc Function will assume a variable named 'score' has been defined.
score = CtkScore.new;

/////////////// DEFINE SYNTH HELPER FUNCTIONS ///////////////

// sine-cosine panning law coefficient function
// angle argument in degrees
sinCosPanLaw = { arg angleInDegrees = 0;
    var angleInRadians;
    var theta;

    angleInRadians = angleInDegrees/180*pi;

    theta = pi/4 - angleInRadians;

    [theta.cos, theta.sin]
};

///////////////// DEFINE SYNTHS //////////////////

// condensed... easier to read?
synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, gain, ris = 0.1, dec = 0.1, freq = 440.0, panAngle = 0.0;

    // variables
    var bus;          // var to specify output bus
    var osc, out;     // vars assigned to audio signals
    var amp, phase;  // a few vars for synthesis
    var ampEnv, env;       // vars for envelope signal
	var curve, level;

    // assign values
    bus = 0;          // first output
    phase = 0;        // phase of oscillator

    // calcs
    amp = gain.dbamp; // convert from gain in dB to linear amplitude scale

    // the amplitude envelope
    //env = Env.linen(ris, 1.0 - (ris + dec), dec);
	env = Env.new([1, -90.dbamp], [1], \exp);

    // the UGen that synthesises the envelope
    ampEnv = EnvGen.kr(env, timeScale: dur);


    // the oscillator
    osc = SinOsc.ar(freq, phase, amp);

    // rescale osc, by multiplying by ampEnv
    osc = ampEnv * osc;

    // expand to two channels - panning
    out = sinCosPanLaw.value(panAngle) * osc;  // <-- Panning happens here!

    // out!!
    Out.ar(bus, out)
});

///////////////// CREATE SCORE POPULATING FUNCTIONS //////////////////

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, gain = -12.0, ris = 0.1, dec = 0.1, freq = 440.0, partialData; // pass in values

    // iterate through the partialData array to generate individual notes to add to the score
    partialData.do({arg thisPartialData, i;
        var thisPartialDur;
        var thisPartialFreq;
        var thisPartialNote;

        var thisPartialGain;
        var thisPartialRatio;
		var thisPartialOffset;

        // retreive partial dur, gain and ratio
        thisPartialDur = thisPartialData.at(0);
        thisPartialGain = thisPartialData.at(1);
        thisPartialRatio = thisPartialData.at(2);
		thisPartialOffset = thisPartialData.at(3);

        thisPartialDur = dur * thisPartialDur; // scale partial dur by dur argument
        thisPartialGain = gain + thisPartialGain; // scale partialGain by gain
		thisPartialFreq = (freq * thisPartialRatio); // multiply freq by ratio, e.g., not necessarily harmonic!
        thisPartialFreq = thisPartialOffset + thisPartialFreq;


        // create a note for each partial...
        thisPartialNote = synthDef.note(
            starttime: start, duration: thisPartialDur
        )
        .dur_(thisPartialDur)
        .gain_(thisPartialGain)
        .ris_(ris)
        .dec_(dec)
        .freq_(thisPartialFreq);

        // then and add note for each partial to the score
        score.add(thisPartialNote);
    })
};

///////////////// SET PARAMETER VALUES //////////////////

// score parameters for Risset's Bell
partialGains = [ 0, -3.5, 0.0, 5.1, 8.5, 4.5, 3.3, 2.5, 2.5, 0.0, 2.5 ];
partialRatios = [ 0.56, 1.56, 0.92, 2.62, 1.19, 1.7, 2.0, 2.74, 3.0, 3.76, 4.07 ];
partialDurs = [ 1, 0.9, 0.65, 0.55, 0.325, 0.35, 0.25, 0.2, 0.15, 0.1, 0.075 ];
partialOffsets = [ 0, 1, 0, 1.7, 0, 0, 0, 0, 0, 0, 0 ];


// group partial durs, gains and ratios into a new array
// NOTE: we could write the following four lines as a function!
partialData = [partialDurs, partialGains, partialRatios, partialOffsets];
partialData = partialData.flop; // invert rows and columns

///////////////// EVALUATE FUNCTIONS //////////////////

// evaluate the additive synthesis function
// args: start, dur, gain, ris, dec, freq, partialData
// this function adds individual partials to the score to be played

additiveFunc.value(
    start: 0.0,
    dur: 20.0,
    gain: -20.0,
    ris: 0.001,
    dec: 0.005,
    freq: 440.0,
    partialData: partialData
);



///////////////// RENDER THE SCORE //////////////////

// write score to sound file with the -write message
// NOTE: we're using argument names to specify the args. For 'duration', we're letting Ctk
//       do the work for us!
score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);
)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui;








////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 2b///////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


/*Attribution:

Germantown A5# bell, Table III: Rossing, Thomas D. Acoustics of Bells. New York: Van Nostrand Reinhold, 1984. Print. Benchmark Papers in Acoustics Ser. ; v. 19. Pg. 85

Component   Freq   Max Amp   Decay   60 db Drop

A4# - 13 c    462.7  -1 db   3.1 db/sec   19.5 sec
A5# - 20      921.6    0        7.8                 7.7
C6# - 10      1102     5        10                  6
F6 - 17         1383  -29      18                   3.3
A6# - 19       1844   12      44                   1.4
C7# +32       2177   -4       25                   2.4
F7# -40        2730   16       30                   2.0
G7 -9            3305    3       49                   1.22
A7# +26       3786    4        33                   1.82*/


(

//////////////// DEFINE VARIABLES ////////////////

var score, synthDef;
var additiveFunc;
var partialGains, partialDurs, partialOffsets, partialData, partialFreqs, partialFreqRatios, partialDecay;

// helper functions
var sinCosPanLaw;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, numOutputChannels, sampleRate;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = 44100;                   // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// create a score
// the additiveFunc Function will assume a variable named 'score' has been defined.
score = CtkScore.new;

/////////////// DEFINE SYNTH HELPER FUNCTIONS ///////////////

// sine-cosine panning law coefficient function
// angle argument in degrees
sinCosPanLaw = { arg angleInDegrees = 0;
    var angleInRadians;
    var theta;

    angleInRadians = angleInDegrees/180*pi;

    theta = pi/4 - angleInRadians;

    [theta.cos, theta.sin]
};

///////////////// DEFINE SYNTHS //////////////////

synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, gain, ris = 0.1, dec = 0.1, freq = 440.0, panAngle = 0.0;

    // variables
    var bus;          // var to specify output bus
    var osc, out;     // vars assigned to audio signals
    var amp, phase;  // a few vars for synthesis
    var ampEnv, env;       // vars for envelope signal
	var curve, level;

    // assign values
    bus = 0;          // first output
    phase = 0;        // phase of oscillator

    // calcs
    amp = gain.dbamp; // convert from gain in dB to linear amplitude scale

    // the amplitude envelope
    //env = Env.linen(ris, 1.0 - (ris + dec), dec);
	env = Env.new([1, -60.dbamp], [1], \exp);

    // the UGen that synthesises the envelope
    ampEnv = EnvGen.kr(env, timeScale: dur);


    // the oscillator
    osc = SinOsc.ar(freq, phase, amp);

    // rescale osc, by multiplying by ampEnv
    osc = ampEnv * osc;

    // expand to two channels - panning
    out = sinCosPanLaw.value(panAngle) * osc;  // <-- Panning happens here!

    // out!!
    Out.ar(bus, out)
});

///////////////// CREATE SCORE POPULATING FUNCTIONS //////////////////

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, gain = -12.0, ris = 0.1, dec = 0.1, freq = 440.0, partialData; // pass in values

    // iterate through the partialData array to generate individual notes to add to the score
    partialData.do({arg thisPartialData, i;
        var thisPartialDur;
        var thisPartialFreq;
        var thisPartialNote;

        var thisPartialGain;
        var thisPartialRatio;
		var thisPartialDecay;
		var calcdPartialDur;

        // retreive partial dur, gain and ratio
        thisPartialDur = thisPartialData.at(0);
        thisPartialGain = thisPartialData.at(1);
        thisPartialFreq = freq * thisPartialData.at(2);
		thisPartialDecay = thisPartialData.at(3);

		calcdPartialDur = dur * (thisPartialDur/thisPartialDecay); // scale partial dur by dur argument
        thisPartialGain = gain + thisPartialGain; // scale partialGain by gain


        // create a note for each partial...
        thisPartialNote = synthDef.note(
            starttime: start, duration: thisPartialDur
        )
        .dur_(calcdPartialDur)
        .gain_(thisPartialGain)
        .ris_(ris)
        .dec_(dec)
        .freq_(thisPartialFreq);

        // then and add note for each partial to the score
        score.add(thisPartialNote);
    })
};

///////////////// SET PARAMETER VALUES //////////////////

// score parameters for Germantown Bell Table III

partialFreqs = [ 462.7, 921.6, 1102, 1383, 1844, 2177, 2730, 3305, 3786 ];
partialGains = [ -1, 0, 5, -29, 12, -4, 16, 3, 4];
partialDurs = [ 19.5, 7.7, 6, 3.3, 1.4, 2.4, 20, 1.22, 1.82];
partialDecay = [ 3.1, 7.8, 10, 18.0, 44.0, 25.0, 30.0, 49.0, 33.0 ];

partialFreqRatios = partialFreqs/880; //maths for freq ratio

"The partial frequency ratios based on A5 / 880 Hz are:  ".post;
partialFreqRatios.value.postln;

// group partial durs, gains and ratios into a new array
// NOTE: we could write the following four lines as a function!
partialData = [partialDurs, partialGains, partialFreqRatios, partialDecay];
partialData = partialData.flop; // invert rows and columns

///////////////// EVALUATE FUNCTIONS //////////////////

// evaluate the additive synthesis function
// args: start, dur, gain, ris, dec, freq, partialData
// this function adds individual partials to the score to be played

additiveFunc.value(
    start: 0.0,
    dur: 0.9871794872,
    gain: -18.0,
    ris: 0.1,
    dec: 1.0,
    freq: 440,
    partialData: partialData
);


///////////////// RENDER THE SCORE //////////////////

// write score to sound file with the -write message
// NOTE: we're using argument names to specify the args. For 'duration', we're letting Ctk
//       do the work for us!
score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);
)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui;



////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 3a//////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

/*
Attibution:

[1] Soundfile

Recorded on November 3rd, 2015
F Romanian Upright Bass
Title: Upright Delicious Bass
Performer: Ben Obee
Technician: Andrew Luck
License: CC BY 2.0
*/

(

/////////// DEFINE VARIABLES //////////////

var score, synthDef;
var additiveFunc;
var partialGains;

// analysis

var path, skipTime, freq, periods, window, sigArray;

// helper functions
var sinCosPanLaw;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, numOutputChannels, sampleRate;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = SoundFile.new(path).sampleRate;                   // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// set analysis vars
path = "~/Desktop//F_BenObee.aif".standardizePath;
skipTime = 0.375;
freq = 172.0;
periods = 2;
window = 'hanningWindow';


// create a score
// the additiveFunc Function will assume a variable named 'score' has been defined.
score = CtkScore.new;

/////////////// DEFINE SYNTH HELPER FUNCTIONS ///////////////

// sine-cosine panning law coefficient function
// angle argument in degrees
sinCosPanLaw = { arg angleInDegrees = 0;
    var angleInRadians;
    var theta;

    angleInRadians = angleInDegrees/180*pi;

    theta = pi/4 - angleInRadians;

    [theta.cos, theta.sin]
};

///////////////// DEFINE SYNTHS //////////////////

// condensed... easier to read?
synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, gain, ris = 0.1, dec = 0.1, freq = 440.0, panAngle = 0.0;

    // variables
    var bus;          // var to specify output bus
    var osc, out;     // vars assigned to audio signals
    var amp, phase;  // a few vars for synthesis
    var ampEnv, env;       // vars for envelope signal

    // assign values
    bus = 0;          // first output
    phase = 0;        // phase of oscillator

    // calcs
    amp = gain.dbamp; // convert from gain in dB to linear amplitude scale

    // the amplitude envelope
	env = Env.new([1, -90.dbamp], [1], \exp);  //same curve used for Risset bell

    // the UGen that synthesises the envelope
    ampEnv = EnvGen.kr(env, timeScale: dur);

    // the oscillator
    osc = SinOsc.ar(freq, phase, amp);

    // rescale osc, by multiplying by ampEnv
    osc = ampEnv * osc;

    // expand to two channels - panning
    out = sinCosPanLaw.value(panAngle) * osc;  // <-- Panning happens here!

    // out!!
    Out.ar(bus, out)
});

///////////////// CREATE SCORE POPULATING FUNCTIONS //////////////////

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, gain = -12.0, ris = 0.1, dec = 0.1, freq = 440.0, partialGains; // pass in values

    // iterate through the partialGains array to generate individual notes to add to the score
    partialGains.do({arg thisPartialGain, i;
        var thisPartialFreq;
        var thisPartialNote;

        thisPartialGain = gain + thisPartialGain; // scale partialGain by gain
        thisPartialFreq = freq * (i + 1);           // multiply freq by index (harmonic series!)

        // create a note for each partial...
        thisPartialNote = synthDef.note(
            starttime: start, duration: dur
        )
        .dur_(dur)
        .gain_(thisPartialGain)
        .ris_(ris)
        .dec_(dec)
        .freq_(thisPartialFreq);

        // then and add note for each partial to the score
        score.add(thisPartialNote);
    })
};

///////////////// SET PARAMETER VALUES //////////////////

//analysis params
sigArray = Signal.readPeriod(
    path: path,  // path
    startFrame: (skipTime * sampleRate).asInteger,  // start frame
    freq: freq,      //F172, in Hz
    numPeriods: periods,  // number of periods to read
	window: window  // the Hann window
);
partialGains = sigArray.analyzeHarmonics(
		periods
	);
(partialGains.at(1).normalize + -90.dbamp);
partialGains = partialGains.ampdb;
"Partial gains after normalization: ".post;
partialGains.at(1).postln;

///////////////// EVALUATE FUNCTIONS //////////////////

// evaluate the additive synthesis function
// args: start, dur, gain, ris, dec, freq, partialGains
// this function adds individual partials to the score to be played
additiveFunc.value(
    start: 0.0,
    dur: 3.0,
    gain: -10,
    ris: 0.1,
    dec: 0.1,
    freq: 172.0/2,
    partialGains: partialGains
);


///////////////// RENDER THE SCORE //////////////////

// write score to sound file with the -write message
// NOTE: we're using argument names to specify the args. For 'duration', we're letting Ctk
//       do the work for us!
score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);
)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui;


////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 3b//////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

/*
Attibution:

[1] Soundfile

Recorded on November 3rd, 2015
F Romanian Upright Bass
Title: Upright Delicious Bass
Performer: Ben Obee
Technician: Andrew Luck
License: CC BY 2.0
*/

(
/////////////////////////////////////////DEFINE VARIABLES///////////////////////////////////////////

var note1, note2, note3, score, synthDef;
var buffer1;
var tableSize;

// helper functions
var sinCosPanLaw;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, numOutputChannels;

// analysis
var path, skipTime, freq, periods, window, sigArray, partialGains, partialRatios, partialPhasesRadians, sampleRate, sigArrayAnalyzed;

//buffer
var sine3Array;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = SoundFile.new(path).sampleRate;  // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// create a score
score = CtkScore.new;

/////////////// DEFINE SYNTH HELPER FUNCTIONS ///////////////

// sine-cosine panning law coefficient function
// angle argument in degrees
sinCosPanLaw = { arg angleInDegrees = 0;
    var angleInRadians;
    var theta;

    angleInRadians = angleInDegrees/180*pi;

    theta = pi/4 - angleInRadians;

    [theta.cos, theta.sin]
};

///////////////// DEFINE SYNTHS //////////////////

synthDef = CtkSynthDef.new(\myOscSynth, {arg dur, gain, ris = 0.1, dec = 0.1, freq = 440.0, panAngle = 0.0, buffer = 0;

    // variables
    var bus = 0;      // var to specify output bus: first output
    var osc, out;     // vars assigned to audio signals
    var amp, phase;  // a few vars for synthesis
    var ampEnv, env;       // vars for envelope signal

    // assign values
    bus = 0;          // first output
    phase = 0;        // phase of oscillator

    // calcs
    amp = gain.dbamp; // convert from gain in dB to linear amplitude scale

    // the amplitude envelope
    //env = Env.linen(ris, 1.0 - (ris + dec), dec);
	env = Env.new([1, -90.dbamp], [1], \exp);

    // the UGen that synthesises the envelope
    ampEnv = EnvGen.kr(env, timeScale: dur);

    // the wavetable oscillator
    osc = Osc.ar(buffer, freq, phase, amp);

    // rescale osc, by multiplying by ampEnv
    osc = ampEnv * osc;

    // expand to two channels - panning
    out = sinCosPanLaw.value(panAngle) * osc;  // <-- Panning happens here!

    // out!!
    Out.ar(bus, out)
});


///////////////// SET PARAMETER VALUES //////////////////

// score parameters
tableSize = 2.pow(14);           // = 16384, 2x bigger than SinOsc!


// set analysis vars
path = "~/Desktop//F_BenObee.aif".standardizePath;
skipTime = 0.375;
freq = 172.0;
periods = 2;
window = 'hanningWindow';
sampleRate = SoundFile.new(path).sampleRate;

//analysis params
sigArray = Signal.readPeriod(
    path: path,  // path
    startFrame: (skipTime * sampleRate).asInteger,  // start frame
    freq: freq,      //F172, in Hz
    numPeriods: periods,  // number of periods to read
	window: window  // the Hann window
);
sigArrayAnalyzed = sigArray.analyzeHarmonics(
		periods
	);

//(sigArrayAnalyzed.at(1).normalize + -90.dbamp);

partialRatios = sigArrayAnalyzed.at(0);
partialGains = sigArrayAnalyzed.at(1);
partialPhasesRadians = sigArrayAnalyzed.at(2);

//partialGains = partialGains.ampdb;

"Partial Ratios: ".post;
sigArrayAnalyzed.at(0).postln;
"Partial Gains (not normalized): ".post;
sigArrayAnalyzed.at(1).postln;
"Partial Phases in Radians: ".post;
sigArrayAnalyzed.at(2).postln;

// CtkBuffer-sine1(time, normalize, wavetable, clear ... args)
//     args = Array with partial amplitudes
//
// For -sine1 we need to do this:

partialGains;  // amplitudes
"sine1: Partial Gains normalized: ".post;
partialGains.normalize.postln;  // or normalized amplitudes


// CtkBuffer-sine2(time, normalize, wavetable, clear ... args)
//     args = Array with partial number (freqs) & amplitudes
//
// For -sine2 we need to do this:
"sine2: Partial ratio and amplitude scale laced: ".post;
sigArrayAnalyzed.drop(-1).lace.postln;  // partial number and amplitude scale


// CtkBuffer-sine3(time, normalize, wavetable, clear ... args)
//     args = Array with partial number (freqs), amplitudes, phases
//
// For -sine3 we need to do this:
"sine3: Partial ratio, Partial Gain AND Partial phase laced: ".post;
sigArrayAnalyzed.lace.postln;  // partial number, amplitude scale and phase
sine3Array = sigArrayAnalyzed.lace;


///////////////// CREATE BUFFERS //////////////////

// create the buffers to play with OSC - MUST be wavetable format:
buffer1 = CtkBuffer.buffer(tableSize).sine3(time: 0.0, normalize: 1, wavetable: 1, clear: 1, args: sine3Array);

///////////////// CREATE SYNTH NOTE CALLS //////////////////

// define the notes
// start, dur, dur, gain, ris, dec freq
note1 = synthDef.note(starttime: 0.0, duration: 4.0).dur_(4.0).gain_(-10.0).freq_(172.0/2).buffer_(buffer1);
// note2 = synthDef.note(starttime: 5.0, duration: 4.0).dur_(4.0).gain_(-12.0).freq_(220.0).buffer_(buffer2);
// note3 = synthDef.note(starttime: 10.0, duration: 4.0).dur_(4.0).gain_(-12.0).freq_(220.0).buffer_(buffer3);

///////////////// POPULATE THE SCORE //////////////////

// ADD buffers (wavetables) to the score
// NOTE: buffers must be added to the score for the CtkSynthDef to access!
//       do this before adding any notes...
score.add(buffer1);

// add notes to the score
score.add(note1);
// score.add(note2);
// score.add(note3);


///////////////// RENDER THE SCORE //////////////////

// write score to sound file with the -write message
score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);

)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui;




////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 4a//////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


(
var amFreqFunc;
var amFreqs;
var numP;

// function to predict AM spectral compenents (single carrier/modulator frequency)
amFreqFunc = {arg carFreq, modFreq, numP;
    var freqAM;
    var freqSum, freqDiff;
	var amFreqs;

	if ( numP.mod(3) != 0,  //if modulo of 3 is not equal to 0, go to true statement
		{ numP = numP.trunc(3); //set new value to the truncated modulo of 3
			"Number of harmonics must be divisibile by 3.".warn;
			numP.post;
			" is the new number of harmonics.".postln;
		},
		{ "good".postln }
	);

	amFreqs = (numP/3).asInteger.collect { arg i;

    freqSum = carFreq*(i+1) + modFreq;
    freqDiff = carFreq*(i+1) - modFreq;
    freqAM = Array.with(carFreq, freqSum, freqDiff);
	};


    freqAM.sort;
	amFreqs.flatten.abs.sort;
};

amFreqFunc.value(440, 660, 50);

)





////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 4b//////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

(

//////////////// DEFINE VARIABLES ////////////////

var score, synthDef;
var additiveFunc;
var partialGains, partialRatios, partialDurs, partialOffset, partialData, partialFreqs, partialArraySize;

// helper functions
var sinCosPanLaw;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, numOutputChannels, sampleRate;

//vars for array generation

var additiveFreqFunc, amFreqs, numP;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = 44100;                   // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// create a score
// the additiveFunc Function will assume a variable named 'score' has been defined.
score = CtkScore.new;

/////////////// DEFINE SYNTH HELPER FUNCTIONS ///////////////

// sine-cosine panning law coefficient function
// angle argument in degrees
sinCosPanLaw = { arg angleInDegrees = 0;
    var angleInRadians;
    var theta;

    angleInRadians = angleInDegrees/180*pi;

    theta = pi/4 - angleInRadians;

    [theta.cos, theta.sin]
};

///////////////// DEFINE SYNTHS //////////////////

// condensed... easier to read?
synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, gain, ris = 0.1, dec = 0.1, freq = 440.0, panAngle = 0.0;

    // variables
    var bus;          // var to specify output bus
    var osc, out;     // vars assigned to audio signals
    var amp, phase;  // a few vars for synthesis
    var ampEnv, env;       // vars for envelope signal
	var curve, level;

    // assign values
    bus = 0;          // first output
    phase = 0;        // phase of oscillator

    // calcs
    amp = gain.dbamp; // convert from gain in dB to linear amplitude scale

    // the amplitude envelope
    //env = Env.linen(ris, 1.0 - (ris + dec), dec);
	env = Env.new([1, -90.dbamp], [1], \exp);

    // the UGen that synthesises the envelope
    ampEnv = EnvGen.kr(env, timeScale: dur);


    // the oscillator
    osc = SinOsc.ar(freq, phase, amp);

    // rescale osc, by multiplying by ampEnv
    osc = ampEnv * osc;

    // expand to two channels - panning
    out = sinCosPanLaw.value(panAngle) * osc;  // <-- Panning happens here!

    // out!!
    Out.ar(bus, out)
});

///////////////// CREATE SCORE POPULATING FUNCTIONS //////////////////

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, gain = -12.0, ris = 0.1, dec = 0.1, freq = 440.0, partialData; // pass in values

    // iterate through the partialData array to generate individual notes to add to the score
    partialData.do({arg thisPartialData, i;
        var thisPartialDur;
        var thisPartialFreq;
        var thisPartialNote;

        var thisPartialGain;
        var thisPartialRatio;
		//var thisPartialOffset;

        // retreive partial dur, gain and ratio
        thisPartialDur = thisPartialData.at(0);
        thisPartialGain = thisPartialData.at(1);
        thisPartialFreq = thisPartialData.at(2);
		//thisPartialOffset = (-3.0).rand2(3.0); //6 Hz range of detuning below or above

        thisPartialDur = dur * thisPartialDur; // scale partial dur by dur argument
        thisPartialGain = gain + thisPartialGain; // scale partialGain by gain
       // thisPartialFreq = thisPartialOffset + thisPartialFreq;


        // create a note for each partial...
        thisPartialNote = synthDef.note(
            starttime: start, duration: thisPartialDur
        )
        .dur_(thisPartialDur)
        .gain_(thisPartialGain)
        .ris_(ris)
        .dec_(dec)
        .freq_(thisPartialFreq);

        // then and add note for each partial to the score
        score.add(thisPartialNote);
    })
};

///////////////// SET PARAMETER VALUES //////////////////


// function to predict AM spectral compenents (single carrier/modulator frequency)
additiveFreqFunc  = {arg carFreq, modFreq, numP;
    var freqAM;
    var freqSum, freqDiff;
	var amFreqs;

	if ( numP.mod(3) != 0,  //if modulo of 3 is not equal to 0, go to true statement
		{ numP = numP.trunc(3); //set new value to the truncated modulo of 3
			"Number of harmonics must be divisibile by 3. Harmonics have been adjusted".warn;
			numP.post;
			" is the new number of harmonics.".postln;
		},
		{ "good".postln }
	);

	amFreqs = (numP/3).asInteger.collect { arg i;

    freqSum = carFreq*(i+1) + modFreq;
    freqDiff = carFreq*(i+1) - modFreq;
    freqAM = Array.with(carFreq, freqSum, freqDiff);
	};


    freqAM.sort;
	amFreqs.flatten.abs.sort;
};

partialFreqs = additiveFreqFunc.value(202.4, 1161.776, 12);

partialFreqs.value.postln;


partialGains = Harmonics.new(partialFreqs.size);
//partialGains = partialGains.decay(1.0).ampdb;  // generating partial gains with decay
// partialGains = partialGains.formant;  // generating partial gains with formant
// partialGains = partialGains.sine;  // generating partial gains with formant
partialGains = partialGains.rand(-3.5, 8.5);  //generating partial gains randomly with a range between -3.5 and 8.5

"Partial Gains for carrier signal: ".post;
partialGains.postln;

partialDurs = Harmonics.new(partialFreqs.size);
// partialDurs = partialDurs.geom;
partialDurs = partialDurs.shelf(0, partialFreqs.size, 1, 0.7); // generating partial durations with a shelf scale from 1.0 to 0.7


//Original Risset values for reference
// partialGains = [ 0, -3.5, 0.0, 5.1, 8.5, 4.5, 3.3, 2.5, 2.5, 0.0, 2.5 ];
// partialDurs = [ 1, 0.9, 0.65, 0.55, 0.325, 0.35, 0.25, 0.2, 0.15, 0.1, 0.075 ];
//partialRatios = [ 0.56, 1.56, 0.92, 2.62, 1.19, 1.7, 2.0, 2.74, 3.0, 3.76, 4.07 ];
//partialOffsets = [ 0, 1, 0, 1.7, 0, 0, 0, 0, 0, 0, 0 ];


// group partial durs, gains and ratios into a new array
// NOTE: we could write the following four lines as a function!
partialData = [partialDurs, partialGains, partialFreqs];
partialData = partialData.flop; // invert rows and columns


///////////////// EVALUATE FUNCTIONS //////////////////

// evaluate the additive synthesis function
// args: start, dur, gain, ris, dec, freq, partialData
// this function adds individual partials to the score to be played

additiveFunc.value(
    start: 0.0,
    dur: 20.0,
    gain: -20.0,
    ris: 0.001,
    dec: 0.005,
    freq: 440.0,
    partialData: partialData
);


///////////////// RENDER THE SCORE //////////////////

// write score to sound file with the -write message
// NOTE: we're using argument names to specify the args. For 'duration', we're letting Ctk
//       do the work for us!
score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);
)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui;













////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 5//////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////




/*
Attribution:

[1] Partial Gains 1

Listed partial gains analyzed from Bb Clarinet tone: A220Hz, @ 38.0 seconds.

Downloaded on April 3rd, 2014
Bb Clarinet
Performer: Christine Bellomy
Technicians: John Ritz, Eric Durian
http://theremin.music.uiowa.edu/sound%20files/MIS/Woodwinds/Bbclarinet/BbClar.mf.D3B3.aiff
License: UNKNOWN

See also:
http://theremin.music.uiowa.edu/MIS-Pitches-2012/MISBbClarinet2012.html
http://theremin.music.uiowa.edu/MIS.html


[2] Partial Gains 2

Listed partial gains analyzed from Bassoon tone: A220Hz, @ 20.5 seconds.

Downloaded on April 3rd, 2014
Bassoon
Performer: Max Wharton
Technicians: Matt Hallaron, Scott Adamson
http://theremin.music.uiowa.edu/sound%20files/MIS/Woodwinds/bassoon/Bassoon.mf.C3B3.aiff
License: UNKNOWN

See also:
http://theremin.music.uiowa.edu/MISbassoon.html
http://theremin.music.uiowa.edu/MIS.html
*/


// Normalised Amplitude Modulation (AM) synthesis design, with complex carrier.
//
(

//////////////// DEFINE VARIABLES ////////////////

var note1, note2, note3, note4, score, synthDef;
var tableSize, buffer;
var carrierPartialGains;

// helper functions
var sinCosPanLaw;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, sampleRate, numOutputChannels, partialGains;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = 44100;                   // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// create a score
score = CtkScore.new;

/////////////// DEFINE SYNTH HELPER FUNCTIONS ///////////////

// sine-cosine panning law coefficient function
// angle argument in degrees
sinCosPanLaw = { arg angleInDegrees = 0;
    var angleInRadians;
    var theta;

    angleInRadians = angleInDegrees/180*pi;

    theta = pi/4 - angleInRadians;

    [theta.cos, theta.sin]
};

///////////////// DEFINE SYNTHS //////////////////

synthDef = CtkSynthDef.new(\myAMSynth, {arg dur, gain, ris = 0.1, dec = 0.1, carFreq = 440.0, modFreq = 440.0, modIndexGain = 0.0,  panAngle = 0.0, buffer = 0;

    // variables
    var bus = 0;      // var to specify output bus: first output
    var carOsc, modOsc;  // oscillators
    var out;          // output!
    var amp;          // a few vars for synthesis
    var ampEnv;       // var for envelope signal
    var normFac;      // normalization factor
    var modIndex;     // modulation index (a scalar)

    // calcs
    amp = gain.dbamp; // convert from gain in dB to linear amplitude scale
    modIndex = modIndexGain.dbamp; // convert " "
    normFac = (1 + (2*modIndex)).reciprocal; // amplitude normalization factor

    // the amplitude envelope nested in the UGen that synthesises the envelope
    ampEnv = EnvGen.kr(
		        Env.new([1, -90.dbamp], [1, 0], \exp),
        timeScale: dur
    );

    modOsc = SinOsc.ar(modFreq, 0, amp * (2*modIndex)); // simple modulator (single sinusoid)
    carOsc = Osc.ar(buffer, carFreq, 0, amp + modOsc);  // complex carrier (multiple sinusoids)
    carOsc = normFac * carOsc;  // normalize carrier oscillator

    // apply the amplitude envelope
    carOsc = ampEnv * carOsc;

    // expand to two channels - panning
    out = sinCosPanLaw.value(panAngle) * carOsc;  // <-- Panning happens here!

    // out!!
    Out.ar(bus, out)
});

///////////////// SET PARAMETER VALUES //////////////////

// score parameters
tableSize = 2.pow(13);           // for the wavetable
// carrierPartialGains = [0.0, -6.0, -9.0]; // gains for 1st three harmonics in dB
// See above, Attribution [1]
// carrierPartialGains = [ 0, -36, -1 ];  // gains for 1st three harmonics in dB
// // See above, Attribution [2]
// carrierPartialGains = [ -18, 0, -19 ];  // gains for 1st three harmonics in dB

partialGains = Harmonics.new(3);
carrierPartialGains = partialGains.rand(-3.5, 8.5);  //generate first three harmonics from 4b


///////////////// CREATE BUFFERS //////////////////

// create the wavetable buffer for carrier - MUST be wavetable format:
buffer = CtkBuffer.buffer(tableSize).sine1(time: 0.0, normalize: 1, wavetable: 1, clear: 1, args: carrierPartialGains.dbamp);

///////////////// CREATE SYNTH NOTE CALLS //////////////////

// modulation freq sub audio rate (tremelo)
// start, dur, dur, gain, ris, dec, carFreq, modFreq, modIndexGain, buffer (wavetable)
// note1 = synthDef.note(starttime: 0.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220.0).modFreq_(2.0).modIndexGain_(-inf).buffer_(buffer);
// note2 = synthDef.note(starttime: 2.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220.0).modFreq_(2.0).modIndexGain_(-9.0).buffer_(buffer);
// note3 = synthDef.note(starttime: 4.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220.0).modFreq_(2.0).modIndexGain_(-3.0).buffer_(buffer);
// note4 = synthDef.note(starttime: 6.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220.0).modFreq_(2.0).modIndexGain_(0.0).buffer_(buffer);


// // modulation freq audio rate (audible side bands, harmonic ratio)
// // start, dur, dur, gain, ris, dec, carFreq, modFreq, modIndexGain, buffer (wavetable)
// note1 = synthDef.note(starttime: 0.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220).modFreq_(220 * 8).modIndexGain_(-36.0).buffer_(buffer);
// note2 = synthDef.note(starttime: 2.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220).modFreq_(220 * 8).modIndexGain_(-18.0).buffer_(buffer);
// note3 = synthDef.note(starttime: 4.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220).modFreq_(220 * 8).modIndexGain_(0.0).buffer_(buffer);
// note4 = synthDef.note(starttime: 6.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220).modFreq_(220 * 8).modIndexGain_(9.0).buffer_(buffer);

// // modulation freq audio rate (audible side bands, harmonic ratio)
// // start, dur, dur, gain, ris, dec, carFreq, modFreq, modIndexGain, buffer (wavetable)
// note1 = synthDef.note(starttime: 0.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220).modFreq_(220 * 5).modIndexGain_(-36.0).buffer_(buffer);
// note2 = synthDef.note(starttime: 2.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220).modFreq_(220 * 5).modIndexGain_(-18.0).buffer_(buffer);
// note3 = synthDef.note(starttime: 4.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220).modFreq_(220 * 5).modIndexGain_(0.0).buffer_(buffer);
// note4 = synthDef.note(starttime: 6.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(220).modFreq_(220 * 5).modIndexGain_(9.0).buffer_(buffer);

// Risset partials @ prime = 220 (& undeciem)
//
// modulation freq audio rate (audible side bands, inharmonic ratio)
// start, dur, dur, gain, ris, dec, carFreq, modFreq, modIndexGain, buffer (wavetable)
// note1 = synthDef.note(starttime: 0.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(202.4).modFreq_(1161.776).modIndexGain_(-inf).buffer_(buffer);
// note2 = synthDef.note(starttime: 2.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(202.4).modFreq_(1161.776).modIndexGain_(-18.0).buffer_(buffer);
// note3 = synthDef.note(starttime: 4.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(202.4).modFreq_(1161.776).modIndexGain_(3.3).buffer_(buffer);
// note4 = synthDef.note(starttime: 6.0, duration: 2.0).dur_(2.0).gain_(-12.0).carFreq_(202.4).modFreq_(1161.776).modIndexGain_(18.0).buffer_(buffer);

note1 = synthDef.note(starttime: 0.0, duration: 20).dur_(20.0).gain_(0.0).carFreq_(202.4).modFreq_(1161.776).modIndexGain_(18.0).buffer_(buffer);


///////////////// POPULATE THE SCORE //////////////////

// add the buffer (wavetable) to the score
// NOTE: the buffer must be added to the score for the CtkSynthDef to access!
score.add(buffer);

// add notes to score
score.add(note1);
/*score.add(note2);
score.add(note3);
score.add(note4);*/

///////////////// RENDER THE SCORE //////////////////

// write score to sound file with the -write message
score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);
)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui



////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////EXTRA CREDIT/////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

//outta time :(

s.quit;