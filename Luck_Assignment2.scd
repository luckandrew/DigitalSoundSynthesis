
////////////////////////////////////////////////////////////////////////////////////////////////////
////Author: Andrew Luck
////DX Arts Digital Sound Synthesis 461A : Jo Anderson, Daniel Peterson
////Attribution: Code snippets from DXArts 461 Tutorial Set
////////////////////////////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 1A///////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


(

//////////////// DEFINE VARIABLES ////////////////

var note, score, synthDef;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, sampleRate, numOutputChannels;
//vars for harmonics
var additiveFunc, partialGains, partialRatios, partialArray, partialNils, numHarmonics;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = 44100;                   // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// create a score
score = CtkScore.new;

/////////////// DEFINE SYNTHS ///////////////

//synth definition
synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, gain, ris = 0.2, dec = 0.2, freq = 440.0;
    var env, envGen, sig, amp;
    amp = gain.dbamp;
    env = Env.linen(ris, 1.0 - (ris + dec), dec);
    envGen = EnvGen.kr(env, levelScale: amp, timeScale: dur);

    sig = SinOsc.ar(freq, 0, envGen);

    Out.ar([0, 1], sig)
});

///////////////// CREATE SCORE POPULATING FUNCTIONS //////////////////

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, gain = -12.0, ris = 0.1, dec = 0.1, freq = 880.0, partialGains, partialRatios; // pass in values

    var partialData;

    // group partial gains and ratios into a new array
    // NOTE: we could have required that this information is passed in to the function in this form..
    partialData = [partialGains, partialRatios];
    partialData = partialData.lace; // interlace the values
    partialData = partialData.reshape((partialData.size/2).asInteger, 2); // regroup values
    // partialData = partialData.flop; // or the .flop method does the above for us in one shot!

    // iterate through the partialData array to generate individual notes to add to the score
    partialData.do({arg thisPartialData, i;
        var thisPartialFreq;
        var thisPartialNote;

        var thisPartialGain;
        var thisPartialRatio;

        // retreive partial gain and ratio
        thisPartialGain = thisPartialData.at(0);
        thisPartialRatio = thisPartialData.at(1);

        thisPartialGain = gain + thisPartialGain; // scale partialGain by gain
        thisPartialFreq = freq * thisPartialRatio; // multiply freq by ratio, e.g., not necessarily harmonic!

        // create a note for each partial...
        thisPartialNote = synthDef.note(
            starttime: start, duration: dur
        )
        .dur_(dur)
        .gain_(thisPartialGain)
        .ris_(ris)
        .dec_(dec)
        .freq_(thisPartialFreq);

        // then and add note for each partial to the score
        score.add(thisPartialNote);
    })
};


///////////////// SET PARAMETER VALUES //////////////////

//var partialNils, partialArray, partialGains, numHarmonics;

numHarmonics = 10;

partialNils = Array.fill(numHarmonics/2, 0);

partialArray = (1/(Array.series(numHarmonics/2, 1,  2)));
//partialArray.postln;

partialGains = [partialArray, partialNils].lace.ampdb;
//partialGains.postln;

partialRatios = Array.series(partialGains.size, 1);  // harmonic series - generated by Array-series

///////////////// EVALUATE FUNCTIONS //////////////////

// evaluate the additive synthesis function
// args: start, dur, gain, ris, dec, freq, partialGains, partialRatios
// this function adds individual partials to the score to be played
additiveFunc.value(
 	    start: 0.1,
 	    dur: 8.0,
	    gain: -15.0,
	    ris: 0.1,
 	    dec: 0.1,
 	    freq: 440.0,
 	    partialGains: partialGains,
 	    partialRatios: partialRatios
 );

score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);
)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui;















////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 1B//////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////


(

//////////////// DEFINE VARIABLES ////////////////

var note, score, synthDef;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, sampleRate, numOutputChannels;
//vars for harmonics
var additiveFunc, partialGains, partialRatios, partialArray, partialNils, numHarmonics;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = 44100;                   // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// create a score
score = CtkScore.new;

/////////////// DEFINE SYNTHS ///////////////

//synth definition
synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, gain, ris = 0.2, dec = 0.2, freq = 440.0;
    var env, envGen, sig, amp;
    amp = gain.dbamp;
    env = Env.linen(ris, 1.0 - (ris + dec), dec);
    envGen = EnvGen.kr(env, levelScale: amp, timeScale: dur);

    sig = SinOsc.ar(freq, 0, envGen);

    Out.ar([0, 1], sig)
});

///////////////// CREATE SCORE POPULATING FUNCTIONS //////////////////

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, gain = -12.0, ris = 0.1, dec = 0.1, freq = 880.0, partialGains, partialRatios; // pass in values

    var partialData;

    // group partial gains and ratios into a new array
    // NOTE: we could have required that this information is passed in to the function in this form..
    partialData = [partialGains, partialRatios];
    partialData = partialData.lace; // interlace the values
    partialData = partialData.reshape((partialData.size/2).asInteger, 2); // regroup values
    // partialData = partialData.flop; // or the .flop method does the above for us in one shot!

    // iterate through the partialData array to generate individual notes to add to the score
    partialData.do({arg thisPartialData, i;
        var thisPartialFreq;
        var thisPartialNote;

        var thisPartialGain;
        var thisPartialRatio;

        // retreive partial gain and ratio
        thisPartialGain = thisPartialData.at(0);
        thisPartialRatio = thisPartialData.at(1);

        thisPartialGain = gain + thisPartialGain; // scale partialGain by gain
        thisPartialFreq = freq * thisPartialRatio; // multiply freq by ratio, e.g., not necessarily harmonic!

        // create a note for each partial...
        thisPartialNote = synthDef.note(
            starttime: start, duration: dur
        )
        .dur_(dur)
        .gain_(thisPartialGain)
        .ris_(ris)
        .dec_(dec)
        .freq_(thisPartialFreq);

        // then and add note for each partial to the score
        score.add(thisPartialNote);
    })
};


///////////////// SET PARAMETER VALUES //////////////////

//////SQUARE///////

// //var partialNils, partialArray, partialGains, numHarmonics;
//
// numHarmonics = 10;
//
// partialNils = Array.fill(numHarmonics/2, 0);
//
// partialArray = (1/(Array.series(numHarmonics/2, 1,  2)));
// //partialArray.postln;
//
// partialGains = [partialArray, partialNils].lace.ampdb;
// //partialGains.postln;
//
// partialRatios = Array.series(partialGains.size, 1);  // harmonic series - generated by Array-series


//////TRIANGLE



// var partialNils, partialArray, partialGains, numHarmonics;

numHarmonics = 10;

partialNils = Array.fill(numHarmonics/2, 0);

partialArray = (1/(Array.series(numHarmonics/2, 3,  2).pow(2)));
//partialArray.postln;

partialGains = [partialArray, partialNils].lace.ampdb;
"Partial Gains is: ".post;
partialGains.postln;

partialRatios = Array.series(partialGains.size, 1);  // harmonic series - generated by Array-series

///////////////// EVALUATE FUNCTIONS //////////////////

// evaluate the additive synthesis function
// args: start, dur, gain, ris, dec, freq, partialGains, partialRatios
// this function adds individual partials to the score to be played
additiveFunc.value(
 	    start: 0.1,
 	    dur: 8.0,
	    gain: -15.0,
	    ris: 0.1,
 	    dec: 0.1,
 	    freq: 440.0,
 	    partialGains: partialGains,
 	    partialRatios: partialRatios
 );

score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);
)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui;











////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////SOLUTION 2///////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

Risset's Bells

Partial No.2	Frequency Ratio3	Magnitude (in dB)4	Duration Scale	Partial Name
0	0.56	0.0	1.0	Hum
1	0.56 (+1)	-3.5	0.9	Hum (beating)
2	0.92	0.0	0.65	Prime
3	0.92 (+1.7)	5.1	0.55	Prime (beating)
4	1.19	8.5	0.325	Tierce
5	1.7	4.5	0.35
6	2.0	3.3	0.25	Nominal
7	2.74	2.5	0.2	(Undeciem)
8	3.0	2.5	0.15	Superquint
9	3.76	0.0	0.1
10	4.07	2.5	0.075	Octave Nominal




Attribution:

[1] Partial Gains

Listed partial gains analyzed from Bb Clarinet tone: A220Hz, @ 38.0 seconds.

Downloaded on April 3rd, 2014
Bb Clarinet
Performer: Christine Bellomy
Technicians: John Ritz, Eric Durian
http://theremin.music.uiowa.edu/sound%20files/MIS/Woodwinds/Bbclarinet/BbClar.mf.D3B3.aiff
License: UNKNOWN

See also:
http://theremin.music.uiowa.edu/MIS-Pitches-2012/MISBbClarinet2012.html
http://theremin.music.uiowa.edu/MIS.html
*/

(

//////////////// DEFINE VARIABLES ////////////////

var score, synthDef;
var additiveFunc;
var partialGains, partialRatios, partialDurs;
var partialData;

// helper functions
var sinCosPanLaw;

// vars for NRT output
var outputPath, headerFormat, sampleFormat, numOutputChannels, sampleRate;

/////////////// SET VARIABLE VALUES ///////////////

// set the NRT vars here...
outputPath = "~/Desktop/testCTK.wav"; // output file path
headerFormat = "WAV";                 // soundfile header format
sampleFormat = "int24";               // soundfile sample format
sampleRate = 44100;                   // sample rate
numOutputChannels = 2;                // stereo --> 2 channels

// create a score
// the additiveFunc Function will assume a variable named 'score' has been defined.
score = CtkScore.new;

/////////////// DEFINE SYNTH HELPER FUNCTIONS ///////////////

// sine-cosine panning law coefficient function
// angle argument in degrees
sinCosPanLaw = { arg angleInDegrees = 0;
    var angleInRadians;
    var theta;

    angleInRadians = angleInDegrees/180*pi;

    theta = pi/4 - angleInRadians;

    [theta.cos, theta.sin]
};

///////////////// DEFINE SYNTHS //////////////////

// condensed... easier to read?
synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, gain, ris = 0.1, dec = 0.1, freq = 440.0, panAngle = 0.0;

    // variables
    var bus;          // var to specify output bus
    var osc, out;     // vars assigned to audio signals
    var amp, phase;  // a few vars for synthesis
    var ampEnv, env;       // vars for envelope signal

    // assign values
    bus = 0;          // first output
    phase = 0;        // phase of oscillator

    // calcs
    amp = gain.dbamp; // convert from gain in dB to linear amplitude scale

    // the amplitude envelope
    env = Env.linen(ris, 1.0 - (ris + dec), dec);

    // the UGen that synthesises the envelope
    ampEnv = EnvGen.kr(env, timeScale: dur);


    // the oscillator
    osc = SinOsc.ar(freq, phase, amp);

    // rescale osc, by multiplying by ampEnv
    osc = ampEnv * osc;

    // expand to two channels - panning
    out = sinCosPanLaw.value(panAngle) * osc;  // <-- Panning happens here!

    // out!!
    Out.ar(bus, out)
});

///////////////// CREATE SCORE POPULATING FUNCTIONS //////////////////

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, gain = -12.0, ris = 0.1, dec = 0.1, freq = 440.0, partialData; // pass in values

    // iterate through the partialData array to generate individual notes to add to the score
    partialData.do({arg thisPartialData, i;
        var thisPartialDur;
        var thisPartialFreq;
        var thisPartialNote;

        var thisPartialGain;
        var thisPartialRatio;

        // retreive partial dur, gain and ratio
        thisPartialDur = thisPartialData.at(0);
        thisPartialGain = thisPartialData.at(1);
        thisPartialRatio = thisPartialData.at(2);

        thisPartialDur = dur * thisPartialDur; // scale partial dur by dur argument
        thisPartialGain = gain + thisPartialGain; // scale partialGain by gain
        thisPartialFreq = freq * thisPartialRatio; // multiply freq by ratio, e.g., not necessarily harmonic!

        // create a note for each partial...
        thisPartialNote = synthDef.note(
            starttime: start, duration: thisPartialDur
        )
        .dur_(thisPartialDur)
        .gain_(thisPartialGain)
        .ris_(ris)
        .dec_(dec)
        .freq_(thisPartialFreq);

        // then and add note for each partial to the score
        score.add(thisPartialNote);
    })
};

///////////////// SET PARAMETER VALUES //////////////////

// score parameters
partialGains = [ 0, -36, -1, -26, -3, -26, -20, -17, -24, -43, -29, -36, -22, -31, -36, -45, -48, -50, -54, -61 ];
partialRatios = [ 1, 2.02, 3.04, 4.06, 5.08, 6.1, 7.12, 8.14, 9.16, 10.18, 11.2, 12.22, 13.24, 14.26, 15.28, 16.3, 17.32, 18.34, 19.36, 20.38 ]; // stretched tuning ratios for each partial
partialDurs = [ 1, 0.92, 0.84, 0.77, 0.71, 0.65, 0.6, 0.55, 0.51, 0.47, 0.43, 0.39, 0.36, 0.33, 0.31, 0.28, 0.26, 0.24, 0.22, 0.2 ];

// group partial durs, gains and ratios into a new array
// NOTE: we could write the following four lines as a function!
partialData = [partialDurs, partialGains, partialRatios];
partialData = partialData.flop; // invert rows and columns

///////////////// EVALUATE FUNCTIONS //////////////////

// evaluate the additive synthesis function
// args: start, dur, gain, ris, dec, freq, partialData
// this function adds individual partials to the score to be played
additiveFunc.value(
    start: 0.1,
    dur: 8.0,
    gain: -15.0,
    ris: 0.1,
    dec: 0.1,
    freq: 220.0,
    partialData: partialData
);


// // play scale: chromatic, from D3
// // args: start, dur, gain, ris, dec, freq, partialData
// additiveFunc.value(
//     start: 0.0,
//     dur: 2.0,
//     gain: -15.0,
//     ris: 0.1,
//     dec: 0.1,
//     freq: 146.832,
//     partialData: partialData
// );
// additiveFunc.value(
//     start: 5.0,
//     dur: 2.0,
//     gain: -15.0,
//     ris: 0.1,
//     dec: 0.1,
//     freq: 155.563,
//     partialData: partialData
// );
// additiveFunc.value(
//     start: 10.0,
//     dur: 2.0,
//     gain: -15.0,
//     ris: 0.1,
//     dec: 0.1,
//     freq: 164.814,
//     partialData: partialData
// );
// additiveFunc.value(
//     start: 15.0,
//     dur: 2.0,
//     gain: -15.0,
//     ris: 0.1,
//     dec: 0.1,
//     freq: 174.614,
//     partialData: partialData
// );
// additiveFunc.value(
//     start: 20.0,
//     dur: 2.0,
//     gain: -15.0,
//     ris: 0.1,
//     dec: 0.1,
//     freq: 184.997,
//     partialData: partialData
// );
// additiveFunc.value(
//     start: 25.0,
//     dur: 2.0,
//     gain: -15.0,
//     ris: 0.1,
//     dec: 0.1,
//     freq: 195.998,
//     partialData: partialData
// );
// additiveFunc.value(
//     start: 30.0,
//     dur: 2.0,
//     gain: -15.0,
//     ris: 0.1,
//     dec: 0.1,
//     freq: 207.652,
//     partialData: partialData
// );
// additiveFunc.value(
//     start: 35.0,
//     dur: 2.0,
//     gain: -15.0,
//     ris: 0.1,
//     dec: 0.1,
//     freq: 220.000,
//     partialData: partialData
// );
// additiveFunc.value(
//     start: 40.0,
//     dur: 2.0,
//     gain: -15.0,
//     ris: 0.1,
//     dec: 0.1,
//     freq: 233.082,
//     partialData: partialData
// );
// additiveFunc.value(
//     start: 45.0,
//     dur: 2.0,
//     gain: -15.0,
//     ris: 0.1,
//     dec: 0.1,
//     freq: 246.942,
//     partialData: partialData
// );

///////////////// RENDER THE SCORE //////////////////

// write score to sound file with the -write message
// NOTE: we're using argument names to specify the args. For 'duration', we're letting Ctk
//       do the work for us!
score.write(
    path: outputPath.standardizePath,
    sampleRate: sampleRate,
    headerFormat: headerFormat,
    sampleFormat: sampleFormat,
    options: ServerOptions.new.numOutputBusChannels_(numOutputChannels)
);
)

SFPlayer("~/Desktop/testCTK.wav".standardizePath).gui;


